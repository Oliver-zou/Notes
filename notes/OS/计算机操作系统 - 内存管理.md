<!-- GFM-TOC -->

* [连续式内存分配](#连续式内存分配)
* [虚拟内存](#虚拟内存)
* [分页系统地址映射](#分页系统地址映射)
* [页面置换算法](#页面置换算法)
    * [1. 最佳](#1-最佳)
    * [2. 最近最久未使用](#2-最近最久未使用)
    * [3. 最近未使用](#3-最近未使用)
    * [4. 先进先出](#4-先进先出)
    * [5. 第二次机会算法](#5-第二次机会算法)
    * [6. 时钟](#6-时钟)
* [分段](#分段)
* [段页式](#段页式)
* [分页与分段的比较](#分页与分段的比较)
<!-- GFM-TOC -->

# 连续式内存分配

## 1. 计算机体系结构及内存分层体系

<div align="center"> <img src="../../pics/ad7d9ecb-10ac-4c9d-b0fc-61ee11a2bf74.png"/> </div><br>

<div align="center"> <img src="../../pics/9ca9d312-514d-4cce-b2b0-4dfa2d6cfcfe.png"/> </div><br>

- 操作系统在内存管理要完成的目标

  - [ ] 抽象：逻辑地址空间
  - [ ] 保护：独立地址空间
  - [ ] 共享：访问相同内存
  - [ ] 虚拟化：更多的地址空间

- 操作系统实现内存管理目标的手段

  程序重定位;分段;分页;虚拟内存;按需分页虚拟内存

## 2.地址空间与地址生成

物理地址空间：硬件支持的地址空间。即加载到内存地址寄存器中的地址，内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip)映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。

逻辑地址空间：一个运行的程序所拥有的内存范围。即程序中的段地址，逻辑地址由两部份组成，段标识符和段内[偏移量](https://baike.baidu.com/item/偏移量)，CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。

<div align="center"> <img src="../../pics/25e3e5ef-e9e9-41e1-a54e-b5c2fb3834e4.png"/> </div><br>

<div align="center"> <img src="../../pics/9cffa352-b1e9-41c7-a6d2-cbc99e1cfb7f.png"/> </div><br>

- 应用程序的逻辑地址是如何映射到物理地址

  <div align="center"> <img src="../../pics/b0f46760-c39a-4909-8431-cb6effcb5251.png"/> </div><br>

  =>CPU方面

  a.运算器ALU需要在逻辑地址的内存内容(CPU要逻辑地址)
  b.内存管理单元MMU寻找在逻辑地址和物理地址之间的映射(然后MMU找逻辑和物理地址的关系)
  c. 控制器从总线发送在物理地址的内存内容的请求(关系找到后，去找对应物理地址)
  =>内存方面
  e.内存发送物理地址内存内容给CPU(物理地址找到了，给CPU)
  =>操作系统方面
  f.建立逻辑地址和物理地址之间的映射(确保程序不相互干扰)

<div align="center"> <img src="../../pics/fd4fca60-6363-4b46-997f-ada2101d4488.png"/> </div><br>

## 3.连续内存分配：内存碎片与分区的动态分配

- 内存碎片问题：空闲内存不能被利用
  外部碎片：在分配单元间的未使用内存
  内部碎片：在分配单元中的未使用内存

- 简单的内存管理方法：
  当一个程序准许运行在内存中时，分配一个连续的区间
  分配一个连续的内存区间给运行的程序以访问数据

- 分区的动态分配策略

  - [ ] 首次适配：现在想分配n字节，从低地址开始找，碰到的第一个空间比n大的空闲块就使用它。

  <div align="center"> <img src="../../pics/2224c5c5-8fd4-4a62-9f14-9963ab5b25bb.png"/> </div><br>

  要想实现首次分配，需要满足以下条件：
  需要存在一个按地址排序的空闲块列表
  分配需要找一个合适的分区
  重分配需要检查，看看自由分区能不能与相邻的空闲分区合并(形成更大的空闲块)，若有

  优点：简单；易于产生更大的空闲块，向着地址空间的结尾

  缺点：
  外部碎片的问题会加剧；不确定性

  - [ ] 最佳适配：为了分配n字节，使用最小的可用空闲块，以致块的尺寸比n大。

    <div align="center"> <img src="../../pics/7baf4934-c03c-4849-af2b-f9567eda8f39.png"/> </div><br>

    目的：避免分割大的空闲块；最小化外部碎片产生的尺寸。
    要想实现最佳分配，需要满足以下条件：
    按尺寸排列的空闲列表
    分配需要寻找一个合适的分区
    重分配需要搜索和合并于相邻的空闲分区，若有

    优点：大部分分配是小尺寸时很有效；简单
    缺点：外部碎片；重分配慢；易产生很多没用的微小碎片。

  - [ ] 最差适配：为了分配n字节，使用最大的可用空闲块，以致块的尺寸比n大。

    <div align="center"> <img src="../../pics/65d514f1-6d25-4314-b7ac-ed3a37699bac.png"/> </div><br>

    目的：避免太多的微小碎片
    要想实现最差分配，需要满足以下条件：
    按尺寸排列的空闲列表
    分配很快(获得最大的分区)
    重分配需要合并于相邻的空闲分区，若有，然后调整空闲块列表
    优点：假如分配时是中等尺寸效果最好
    缺点：重分配慢；外部碎片；易于破碎大的空闲块以至大分区不能被分割

## 4.连续内存分配：压缩式与交换式碎片整理

- 压缩式碎片整理(紧致)
  重制程序以合并孔洞
  要求所有程序是 动态可重置的
  问题：何时重置；开销。
- 交换式碎片整理
  运行程序需要更多的内存
  抢占等待的程序或回收它们的内存(把暂时不用的内容挪到磁盘里)

# 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

# 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"/> </div><br>

# 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

## 1. 最佳

> OPT, Optimal replacement algorithm

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：

```html
7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
```

开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

## 2. 最近最久未使用

> LRU, Least Recently Used

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

```html
4，7，0，7，1，0，1，2，1，2，6
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"/> </div><br>
## 3. 最近未使用

> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

## 4. 先进先出

> FIFO, First In First Out

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面换出，导致缺页率升高。

## 5. 第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"/> </div><br>

## 6. 时钟

> Clock

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"/> </div><br>

# 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"/> </div><br>

分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"/> </div><br>

# 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

# 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

- 地址空间的维度：分页是一维地址空间，分段是二维的。

- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。

- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
