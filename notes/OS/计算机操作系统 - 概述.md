<!-- GFM-TOC -->
* [基本概念](#基本概念)
* [基本特征](#基本特征)
    * [1. 并发](#1-并发)
    * [2. 共享](#2-共享)
    * [3. 虚拟](#3-虚拟)
    * [4. 异步](#4-异步)
* [基本功能](#基本功能)
    * [1. 进程管理](#1-进程管理)
    * [2. 内存管理](#2-内存管理)
    * [3. 文件管理](#3-文件管理)
    * [4. 设备管理](#4-设备管理)
* [操作系统的启动](#操作系统的启动)
* [中断、异常和系统调用](#中断、异常和系统调用)
* [系统调用](#系统调用)
* [宏内核和微内核](#宏内核和微内核)
    * [1. 宏内核](#1-宏内核)
    * [2. 微内核](#2-微内核)
* [中断分类](#中断分类)
    * [1. 外中断](#1-外中断)
    * [2. 异常](#2-异常)
    * [3. 陷入](#3-陷入)
<!-- GFM-TOC -->

# 基本概念

1. 从用户角度出发，操作系统是一个控制软件，它能提供如下功能：

- 管理应用程序
- 为应用程序提供服务
- 杀死应用程序
- 资源管理
- 管理外设/分配资源

2. 在操作系统下，进程是CPU的抽象, 文件是磁盘的抽象，地址空间是内存的抽象。

3. 操作系统的架构层次：硬件之上，应用软件之下(为应用软件提供服务支持)。

   Linux，Windows界面属于外壳shell(与User交互)，而不是内核kernel，而kernel是研究重点，在shell之下。Kernel包括：

   - CPU调度器
   - 物理内存管理
   - 虚拟内存管理
   - 文件系统管理
   - 中断处理和IO设备驱动 (底层硬件)

4. OS Kernel的特征：

   - **并发**(指一段时间内多个程序运行；而并行是指一个时间点上多个程序运行，要求多个CPU):计算机系统中同时存在多个运行的程序，需要OS管理和调度
   - **共享**：“同时”访问 或 互斥共享
   - **虚拟**：利用多道程序设计技术，让每一个用户都觉得有一个计算机专门为他服务
   - **异步**：程序的执行不是一步到底的，而是走走停停，向前推进的速度不可预知，但只要运行环境相同，OS要保证程序运行的结果也相同

5. 操作系统需要权衡

空间与时间，性能和可预测性，公平和性能。



# 基本特征

## 1. 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

操作系统通过引入进程和线程，使得程序能够并发运行。

## 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。

互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

## 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 4. 异步

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

# 基本功能

## 1. 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

## 2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

## 3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

## 4. 设备管理

完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

# 操作系统的启动

1. CPU, I/O, 内存通过总线连接。

2. DISK:存放OS；

   BIOS：基本I/O处理系统( basic I/O system); Bootloader: 加载OS到内存中。

3. 当电脑通电时，段寄存器CS和指令寄存器IP能够确定一个内存地址，例如CS:IP = 0xf000:fff0.

4. POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)。

5. BIOS: 将Bootloader从磁盘的磁盘的引导扇区(512字节)加载到0x7c00；跳转到CS:IP=0000:7c00的内存区域(以便下一步)
   Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址。

为什么应用程序不能直接访问硬件而是通过操作系统？

- 计算机运行时，内核是被信任的第三方。
- 只有内核可以执行特权指令。
- 为了方便应用程序。

# 中断、异常和系统调用

系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求。
异常：(来源于不良的应用程序)非法指令或其它花的处理状态(e.g.内存出错)。
中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断。

- 产生的源头

  中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)
  异常：应用程序意想不到的行为(e.g.异常，恶意程序，应用程序需要的资源未得到满足)
  系统调用：应用程序请求操作提供服务(e.g.打开/关闭/读写文件，发送网络包)

- 处理时间
  中断：异步；
  异常：同步；
  系统调用：同步或异步。

- 响应
  中断：持续，对用户应用程序时透明的
  异常：杀死或者重新执行意想不到的应用程序指令
  系统调用：等待和持续

- 中断/异常处理机制
  中断是外设的事件，异常是CPU的事件；中断/异常迫使CPU访问一些被中断和异常服务访问的功能。

- 中断处理机制
  硬件：设置中断标记(CPU初始化)；将内部/外部事件设置中断标记；中断事件的ID(程序访问的中断向量地址)
  软件(操作系统)：
  保存当前处理状态：中断服务程序处理；清除中断标记；恢复之前保存的处理状态

- 异常处理机制
  异常：异常编号
  保存现场
  异常处理：杀死产生异常的程序；重新执行异常指令
  恢复现场

- 系统调用
  一条指令会触发一个系统调用，程序访问主要是通过高层次的API接口而不是直接进行系统调用。通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引。系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值。用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理。

  用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)。
  内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)。
  系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)。

- 跨越操作系统边界的开销

  在执行时间上超过程序调用，开销包括：
  建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销；
  建立内核堆栈(操作系统和应用程序的堆栈不一样)；
  验证参数(操作系统会检查数据)；
  内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；
  内核态独立地址空间TLB。

# 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" width="600"/> </div><br>

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

# 宏内核和微内核

## 1. 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

## 2. 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg"/> </div><br>

# 中断分类

## 1. 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

## 2. 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

## 3. 陷入

在用户程序中使用系统调用。


